# Fluentd設定ファイル
# Task 5.3: ログ転送機能実装

# 共有ボリューム方式の場合（デフォルト）
<source>
  @type tail
  @id nginx_access
  path /var/log/nginx/*/access.log
  pos_file /var/log/fluentd/nginx.access.*.pos
  tag nginx.access.${File.dirname(path).split('/').last}
  # 一時的なタグ（FQDNのみ）: nginx.access.example1.com
  <parse>
    @type json
    time_key time
    time_format %Y-%m-%dT%H:%M:%S%z
  </parse>
  @if "#{ENV['LOG_COLLECTION_METHOD']}" == "shared-volume" || "#{ENV['LOG_COLLECTION_METHOD']}" == "hybrid"
</source>

# Nginxアクセスログのタグを完全な形式に変換（ホスト名、顧客名、FQDN名、年、月、日、時間を含む）
<filter nginx.access.**>
  @type record_transformer
  enable_ruby true
  <record>
    # メタデータをレコードに追加
    log_type "nginx"
    hostname "#{ENV['HOSTNAME'] || Socket.gethostname}"
    customer_name ${record["customer_name"] || ENV["CUSTOMER_NAME"] || "default"}
    fqdn ${tag_parts[2..-1].join('.')}
    year ${Time.at(time).strftime("%Y")}
    month ${Time.at(time).strftime("%m")}
    day ${Time.at(time).strftime("%d")}
    hour ${Time.at(time).strftime("%H")}
    minute ${Time.at(time).strftime("%M")}
    second ${Time.at(time).strftime("%S")}
  </record>
  # タグを動的に生成: nginx.access.{hostname}.{customer_name}.{fqdn}.{year}.{month}.{day}.{hour}
  tag "nginx.access.${record['hostname']}.${record['customer_name']}.${record['fqdn']}.${record['year']}.${record['month']}.${record['day']}.${record['hour']}"
</filter>

# ログドライバ方式の場合
<source>
  @type forward
  @id docker_logs
  port 24224
  bind 0.0.0.0
  @if "#{ENV['LOG_COLLECTION_METHOD']}" == "log-driver" || "#{ENV['LOG_COLLECTION_METHOD']}" == "hybrid"
</source>

<source>
  @type tail
  @id nginx_error
  path /var/log/nginx/*/error.log
  pos_file /var/log/fluentd/nginx.error.*.pos
  tag nginx.error.${File.dirname(path).split('/').last}
  # 一時的なタグ（FQDNのみ）: nginx.error.example1.com
  <parse>
    # Nginxエラーログの形式: YYYY/MM/DD HH:MM:SS [level] pid.tid: message
    @type regexp
    expression /^(?<time>\d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2}) \[(?<level>[^\]]+)\] (?<pid>\d+).(?<tid>\d+): (?<message>.*)$/
    time_format %Y/%m/%d %H:%M:%S
  </parse>
  @if "#{ENV['LOG_COLLECTION_METHOD']}" == "shared-volume" || "#{ENV['LOG_COLLECTION_METHOD']}" == "hybrid"
</source>

# Nginxエラーログのタグを完全な形式に変換（ホスト名、顧客名、FQDN名、年、月、日、時間を含む）
<filter nginx.error.**>
  @type record_transformer
  enable_ruby true
  <record>
    # メタデータをレコードに追加
    log_type "nginx"
    hostname "#{ENV['HOSTNAME'] || Socket.gethostname}"
    # 注意: Nginxエラーログにはcustomer_nameが含まれていないため、
    # 環境変数ENV["CUSTOMER_NAME"]またはデフォルト値"default"にフォールバックします
    # これにより、エラーが発生したリクエスト固有の顧客名を特定できなくなります
    # 将来的に、FQDNと顧客名をマッピングする仕組みを導入することを検討してください
    customer_name ${record["customer_name"] || ENV["CUSTOMER_NAME"] || "default"}
    fqdn ${tag_parts[2..-1].join('.')}
    year ${Time.at(time).strftime("%Y")}
    month ${Time.at(time).strftime("%m")}
    day ${Time.at(time).strftime("%d")}
    hour ${Time.at(time).strftime("%H")}
    minute ${Time.at(time).strftime("%M")}
    second ${Time.at(time).strftime("%S")}
  </record>
  # タグを動的に生成: nginx.error.{hostname}.{customer_name}.{fqdn}.{year}.{month}.{day}.{hour}
  tag "nginx.error.${record['hostname']}.${record['customer_name']}.${record['fqdn']}.${record['year']}.${record['month']}.${record['day']}.${record['hour']}"
</filter>

<source>
  @type tail
  @id openappsec_detection
  path /var/log/nano_agent/*.log
  pos_file /var/log/fluentd/openappsec.detection.*.pos
  tag openappsec.detection
  <parse>
    @type json
    time_key time
    time_format %Y-%m-%dT%H:%M:%S%z
  </parse>
  @if "#{ENV['LOG_COLLECTION_METHOD']}" == "shared-volume" || "#{ENV['LOG_COLLECTION_METHOD']}" == "hybrid"
</source>

# OpenAppSecログをFQDN別にタグ付け（中間ステップ）
<filter openappsec.detection>
  @type rewrite_tag_filter
  <rule>
    key host
    pattern /^(.+)$/
    tag openappsec.detection.${1}
  </rule>
  # hostフィールドがない場合のフォールバック
  <rule>
    key hostname
    pattern /^(.+)$/
    tag openappsec.detection.${1}
  </rule>
  # requestHostフィールドのフォールバック
  <rule>
    key requestHost
    pattern /^(.+)$/
    tag openappsec.detection.${1}
  </rule>
  # デフォルトタグ（FQDNが取得できない場合）
  <rule>
    key _
    pattern /.*/
    tag openappsec.detection.unknown
  </rule>
</filter>

# OpenAppSecログのタグを完全な形式に変換（ホスト名、顧客名、FQDN名、signature、protectionName、ruleName、年、月、日、時間を含む）
<filter openappsec.detection.**>
  @type record_transformer
  enable_ruby true
  <record>
    # メタデータをレコードに追加
    log_type "openappsec"
    source "waf-engine"
    # タグからFQDNを抽出（タグ形式: openappsec.detection.{fqdn}）
    fqdn ${tag_parts[2..-1].join('.')}
    # ホスト名（環境変数またはコンテナ名から取得）
    hostname "#{ENV['HOSTNAME'] || Socket.gethostname}"
    # 注意: OpenAppSecの検知ログにはcustomer_nameが含まれていないため、
    # 環境変数ENV["CUSTOMER_NAME"]またはデフォルト値"default"にフォールバックします
    # これにより、WAFイベントをリクエスト固有の顧客名と正確に関連付けることが難しくなります
    # 将来的に、FQDNと顧客名をマッピングする仕組みを導入することを検討してください
    customer_name ${record["customer_name"] || ENV["CUSTOMER_NAME"] || "default"}
    # シグニチャ情報（OpenAppSecログから抽出）
    signature ${(record["signature"] || "unknown").downcase.gsub(/[^a-z0-9_-]/, "_")}
    protection_name ${(record["protectionName"] || "unknown").downcase.gsub(/[^a-z0-9_-]/, "_")}
    rule_name ${(record["ruleName"] || "unknown").downcase.gsub(/[^a-z0-9_-]/, "_")}
    # 日時情報を抽出（timeフィールドから）
    year ${Time.at(time).strftime("%Y")}
    month ${Time.at(time).strftime("%m")}
    day ${Time.at(time).strftime("%d")}
    hour ${Time.at(time).strftime("%H")}
    minute ${Time.at(time).strftime("%M")}
    second ${Time.at(time).strftime("%S")}
  </record>
  # タグを動的に生成: openappsec.detection.{hostname}.{customer_name}.{fqdn}.{signature}.{protectionName}.{ruleName}.{year}.{month}.{day}.{hour}
  tag "openappsec.detection.${record['hostname']}.${record['customer_name']}.${record['fqdn']}.${record['signature']}.${record['protection_name']}.${record['rule_name']}.${record['year']}.${record['month']}.${record['day']}.${record['hour']}"
</filter>

# FQDN別のログファイル出力（オプション）
<match openappsec.detection.**>
  @type file
  path /var/log/fluentd/output/openappsec_fqdn/${tag_parts[2..-1].join('.')}/detection
  append true
  <format>
    @type json
  </format>
  <buffer tag,time>
    @type file
    path /var/log/fluentd/buffer/openappsec
    timekey 1d
    timekey_wait 10m
    timekey_use_utc true
  </buffer>
</match>

# NginxログとOpenAppSecログの統合出力設定（HTTP/HTTPS）
<match {nginx,openappsec}.**>
  @type http
  endpoint "#{ENV['FLUENTD_OUTPUT_URL']}"
  http_method post
  # 認証情報の設定（環境変数が設定されている場合のみ）
  # Bearerトークン認証の場合
  <headers>
    Authorization "Bearer #{ENV['FLUENTD_OUTPUT_AUTH']}"
  </headers>
  # Basic認証の場合（コメントアウト）
  # <headers>
  #   Authorization "Basic #{ENV['FLUENTD_OUTPUT_AUTH']}"
  # </headers>
  <buffer>
    @type file
    path /var/log/fluentd/buffer
    flush_interval 5s
    retry_type exponential_backoff
    retry_wait 1s
    retry_max_interval 60s
    retry_timeout 60m
  </buffer>
  @if "#{ENV['FLUENTD_OUTPUT_METHOD']}" == "http" || "#{ENV['FLUENTD_OUTPUT_METHOD']}" == "https"
</match>

# デフォルト出力（stdout、開発・デバッグ用）
<match **>
  @type stdout
  @if "#{ENV['FLUENTD_OUTPUT_METHOD']}" == "stdout" || "#{ENV['FLUENTD_OUTPUT_URL']}" == "stdout" || "#{ENV['FLUENTD_OUTPUT_URL']}" == ""
</match>
